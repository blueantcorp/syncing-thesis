
\chapter{Designing a Synchronization Framework}\label{main}

\section{Application Scenarios}
We describe common synchronization scenarios based on popular mobile applications.

\subsection{Relational Data Synchronization}

The Wunderlist app serves as an example for a common kind of data model
that requires syncing of data in a relational schema.

Wunderlist's schema could be defined as the following:

\begin{itemize}
\item User (name, email, has Todo Lists)
\item Invited User (name, email)
\item Invited User List (has Invited Users)
\item Todo Item (title, description, due date, belongs to Todo List)
\item Todo List (name, belongs to Users, has Todo Items)
\end{itemize}

The User type has a singleton instance who represents the user of the
app.\\Users can be invited to Todo Lists. As their list of Todo Lists is
hidden from the current user Invited User is a separate type.\\Invited
User List is simply a cached list of all users that have been invited in
the past.\\While Invited User List is an unordered list, Todo Lists and
Todo Items are ordered.

Syncing lists of unordered object IDs never causes conflicts while
syncing ordered object IDs can cause order conflicts.

\subsection{Hierarchical Data Synchronization}

Dropbox synchronizes a file system - it is therefore a good example for
syncing of hierarchical data.

The data model is simple:

\begin{itemize}
\item Tree Item (name)
\item Tree extends Tree Item (has children of type Tree Items)
\item Data extends Tree Item (data)
\end{itemize}

The list of child Tree Items can either be ordered or unordered. While
Dropbox does not sync the order of files there are scenarios where this
is required.

Syncing trees can trigger conflicts if sub trees have been modified
concurrently.

\subsection{(Text Synchronization)}

Collaborative document editors like Google Docs need to synchronize text
that is concurrently edited.\\Google Docs currently does not support
offline editing.

Syncing text is equal to the problem of syncing an ordered list and can
trigger conflicts.

\section{Requirements}
\label{sec:requirements}
From the common scenarios we derive a set of requirements for a synchronization solution.

Requirements for strategies:

\begin{itemize}
\item Causality preservation
\item Eventual consistency
\item Optimistic synchronization
\item Expose conflicts
\item Support peer-to-peer or hybrid synchronization
\item Integration with existing app logic
\end{itemize}

(TODO: need to explain why this set of requirements, constraints on
mobile devices\ldots{})

Aspects to consider when evaluating strategies:

\begin{itemize}
\item How are updates detected?
\item How are updates propagated? (Stream or Snapshot)
\item How are updates merged/reconciled? (State or Edit-based)
\item Level of structural awareness (Textual, Syntactic, Semantic/Structural)
\end{itemize}

\section{Evaluating Existing Systems}
Here we evaluate existing solutions based on the requirements.

\subsection{git}

\begin{itemize}
\item
  Data structure: filesystem/tree
\item
  Merging: tree-based, three-way merge
\item
  Propagation: snapshot-based
\item
  Supports peer-to-peer
\end{itemize}

\subsection{CouchDB}

\begin{itemize}
\item
  Data structure: key-value
\item
  Merging: tree-based
\item
  Propagation: stream-based
\item
  Supports peer-to-peer
\end{itemize}

\subsection{(Backends-as-a-Service)}
- parse.com
- stackmob
- deployd

Most of them simply expose a REST-API but leave all the conflict handling work to the app developer.\\
Are completely centralized.

\section{Architecture of Synclib}
Based on the requirements and the evaluation of existing systems we derive a unique architecture for a practical synchronization solution.

\begin{itemize}
\item
  \textbf{no timestamps}: state-based 3-way merging
\item
  \textbf{no change tracing}: change tracing is not necessary - support
  diff computation on the fly
\item
  \textbf{data agnostic}: leave diff and merge of the actual data to
  plugins
\item
  \textbf{distributed}: syncing does not require a central server
\item
  \textbf{be small}: only implement the functional parts of syncing -
  leave everything else to the application (transport, persistence)
\item
  \textbf{sensitive defaults}: have defaults that \emph{just work} but
  still support custom logic (e.g.~for conflict resolution)
\end{itemize}

- cross-platform through web standards
- solve server behaviour through native proxy
- diff-merge-patch
- most-recent-common-ancestor

\section{Technologies used for Implementation}
We describe implementation details like the technologies used, code structure and the testing framework to evaluate the system.

- everything web-based --> only way to be cross-platform
- client-side persistence with HTML5
- note on alternatives (Lua, native)

\section{Differencing and Merging of Data Models}
- explain diff, merge and patch
- implement diff, merge and patch logic for primitive data structures
  -> use them to recursively model complex data structures
- ensure conflicts are made explicit

\subsection{Sets}
\subsection{Ordered Lists}
\subsection{Ordered Sets}
\subsection{Dictionaries}
used for object collections in data models
\subsection{Ordered Dictionaries}
most common for managing ordered object collections in data models
can be modeled with dictionary and ordered set/list
\subsection{Trees}
- tree as an example for composite data model
- efficient child tree pointers like in git

\subsection{Composite Data Structures}
- show how to represent complex data models as composite data structures

\section{Storing and Commiting Changes}
As syncing is state based we need to track the history of edits on each client.\\Each client has his own replica of the database and commits
data locally.\\On every commit we create a commit object that links both
to the new version of the data and the previous commit.\\

- use content-adressable store
- only store changes and reference unchanged data through hashs --> like git
- commit links to data and parent commit

\section{Finding Common Commits}
- Most Recent Common Ancestor algorithm used for finding common commit of clients
- described algorithm in background
- implementation as separate module

\section{Synchronization Protocol}
If a client is connected to a server he will start the sync process on every commit. As
synclib2's architecture is distributed a server could itself be a client
who is connected to other servers.\\To the latest commit on a database
we refer to as the `head'.

Synchronization follows the following protocol:

\begin{verbatim}
Client has committed to its local database.
Client pushs all commits since the last synced commit to Server.
Client asks Server for the common ancestor of client's head and the server's head
Client pushs all changed data since the common ancestor to Server.

if common ancestor == server head
  // there is no data to merge
  try fast-forward of server's head to client's head
  if failed (someone else updated server's head in the meantime) then start over
else
  Client asks Server for all commits + data since the common ancestor
  Client does a local merge and commits it to the local database
  start over
\end{verbatim}

This protocol is able to minimize the amount of data sent between synced
stores even in a distributed, peer-to-peer setting.

Updating the server's head uses optimistic locking. To update the head
you need to include the last read head in your request.

\section{Handling Conflicts}

\section{Integration with Application Logic}
- demonstrate how to interface with standard MVC frameworks like Backbone, Ember.js

\section{(Managing Changes to Distributed Logic)}
The additional client logic has to be maintained and upgraded for new releases of the application. As the client logic is distributed among all users of the application, a code upgrade becomes more complex to manage than a simple server update. We will see how the same logic used to synchronize application data can be used for updating distributed application code.

- on the server its easy - we can use a distributed version control system
- they don't run on the client -> we need an app-embedded solution

