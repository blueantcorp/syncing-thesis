
\chapter{Designing a Synchronization Framework}\label{main}

\section{Application Scenarios}
We describe common synchronization scenarios based on popular mobile applications.

\subsection{Relational Data Synchronization}

The Wunderlist app serves as an example for a common kind of data model
that requires syncing of data in a relational schema.

Wunderlist's schema could be defined as the following:

\begin{itemize}
\item User (name, email, has Todo Lists)
\item Invited User (name, email)
\item Invited User List (has Invited Users)
\item Todo Item (title, description, due date, belongs to Todo List)
\item Todo List (name, belongs to Users, has Todo Items)
\end{itemize}

The User type has a singleton instance who represents the user of the
app.\\Users can be invited to Todo Lists. As their list of Todo Lists is
hidden from the current user Invited User is a separate type.\\Invited
User List is simply a cached list of all users that have been invited in
the past.\\While Invited User List is an unordered list, Todo Lists and
Todo Items are ordered.

Syncing lists of unordered object IDs never causes conflicts while
syncing ordered object IDs can cause order conflicts.

\subsection{Hierarchical Data Synchronization}

Dropbox synchronizes a file system - it is therefore a good example for
syncing of hierarchical data.

The data model is simple:

\begin{itemize}
\item Tree Item (name)
\item Tree extends Tree Item (has children of type Tree Items)
\item Data extends Tree Item (data)
\end{itemize}

The list of child Tree Items can either be ordered or unordered. While
Dropbox does not sync the order of files there are scenarios where this
is required.

Syncing trees can trigger conflicts if sub trees have been modified
concurrently.

\subsection{Text Synchronization}

Collaborative document editors like Google Docs need to synchronize text
that is concurrently edited.\\Google Docs currently does not support
offline editing.

Syncing text is equal to the problem of syncing an ordered list and can
trigger conflicts.

\section{Requirements}
\label{sec:requirements}
From the common scenarios we derive a set of requirements for a synchronization solution.

Requirements for strategies:

\begin{itemize}
\item Causality preservation
\item Eventual consistency
\item Optimistic synchronization
\item Expose conflicts
\item Support peer-to-peer or hybrid synchronization
\end{itemize}

(TODO: need to explain why this set of requirements, constraints on
mobile devices\ldots{})

Aspects to consider when evaluating strategies:

\begin{itemize}
\item How are updates detected?
\item How are updates propagated? (Stream or Snapshot)
\item How are updates merged/reconciled? (State or Edit-based)
\item Level of structural awareness (Textual, Syntactic, Semantic/Structural)
\end{itemize}

\section{Existing Systems}

\subsection{git}

\begin{itemize}
\item
  Data structure: filesystem/tree
\item
  Merging: tree-based, three-way merge
\item
  Propagation: snapshot-based
\item
  Supports peer-to-peer
\end{itemize}

\subsection{CouchDB}

\begin{itemize}
\item
  Data structure: key-value
\item
  Merging: tree-based
\item
  Propagation: stream-based
\item
  Supports peer-to-peer
\end{itemize}

\section{Evaluation of Existing Systems}
Here we evaluate solutions like CouchDB, Dropbox, iCloud, git, (Google Docs), (Parse.com) based on the requirements.

\section{Architecture of Synclib}
Based on the requirements and the evaluation of existing systems we derive a unique architecture for a practical synchronization solution.

\begin{itemize}
\item
  \textbf{no timestamps}: state-based 3-way merging
\item
  \textbf{no change tracing}: change tracing is not necessary - support
  diff computation on the fly
\item
  \textbf{data agnostic}: leave diff and merge of the actual data to
  plugins
\item
  \textbf{distributed}: syncing does not require a central server
\item
  \textbf{be small}: only implement the functional parts of syncing -
  leave everything else to the application (transport, persistence)
\item
  \textbf{sensitive defaults}: have defaults that \emph{just work} but
  still support custom logic (e.g.~for conflict resolution)
\end{itemize}

\section{Implementation}
We describe implementation details like the technologies used, code structure and the testing framework to evaluate the system.

As syncing is state based we need to track the entire history of a
database.\\Every client has his own replica of the database and commits
data locally.\\On every commit we create a commit object that links both
to the new version of the data and the previous commit.\\If a client is
connected to a server he will start the sync process on every commit. As
synclib2's architecture is distributed a server could itself be a client
who is connected to other servers.\\To the latest commit on a database
we refer to as the `head'.

Syncing follows the following protocol:

\begin{verbatim}
Client has committed to its local database.
Client pushs all commits since the last synced commit to Server.
Client asks Server for the common ancestor of client's head and the server's head
Client pushs all changed data since the common ancestor to Server.

if common ancestor == server head
  // there is no data to merge
  try fast-forward of server's head to client's head
  if failed (someone else updated server's head in the meantime) then start over
else
  Client asks Server for all commits + data since the common ancestor
  Client does a local merge and commits it to the local database
  start over
\end{verbatim}

This protocol is able to minimize the amount of data sent between synced
stores even in a distributed, peer-to-peer setting.

Updating the server's head uses optimistic locking. To update the head
you need to include the last read head in your request.
