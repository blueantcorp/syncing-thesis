
\section{Synchronization Topologies}
\label{sec:histo.topologies}

In this section we will look at different network topologies to evaluate how they are supported by our synchronization protocol.
We will further explore options for optimization of our protocol with regards to each topology.\\

\subsection{Master - Client}
\label{sec:histo.topologies.master-client}
In a Master-Client or Client-Server setup we have a single server which handles all data propagation.
The clients can only synchronize their data with the server and directly with each other.
With regards to our synchronization protocol, this means each client has to remember only one remote tracking head.\\
We can optimize our protocol by adding a data pruning step.
As explained in section \ref{sec:histo.protocol}, each commit corresponds to a synchronization point between two nodes.
As we only synchronize with the server, the ancestor commit of a client's head is always equal to the client's remote tracking head of the server.
We can therefore prune all data on the client that is neither part of our branch head nor the remote tracking head.
Pruning is defined as deleting all objects in our store whose hashes are not referenced in the data hierarchy of the commits we want to keep.
We effectively only keep our current data and the data we received last from the server.
In terms of memory usage of the client's store, this topology is therefore the most efficient one.\\
Same is true for the computation of commit and data differences as described in section \ref{sec:histo.diff-across-commits}.
Running the protocol with the client as the source and the server as the target, the lowest common ancestor of the source's head and the source's remote tracking head is always the remote tracking head itself.
We therefore only need to compute the commit difference between the current head and the ancestor commit which is the remote tracking head.\\
These optimizations do not apply for running the protocol with the server as the source and the client as the target.
The server could have synchronized with other client nodes in the meantime which means that its head is more than one commit ahead of the client.

\subsection{Client - Client}
A client-client or peer-to-peer topology is the opposite extreme of a client-server setup.
Every client can directly synchronize with any other client.
On a network with $ n $ nodes, each node potentially synchronizes with $ n - 1 $ other nodes and therefore has to remember $ n - 1 $ remote tracking heads.\\
We can still apply some optimizations in the form of data pruning.
Let $ A $ be the remote tracking head with the largest distance to a node's head.
All data that is not part of any commit between a node's own head and the lowest common ancestor with $ A $ can be deleted.
It means we only keep the data history until the state of the most outdated node in the network.\\
To maximize the efficiency of this pruning technique, we have to ensure that each node on the system has the best possible information on other node's heads.
We can therefore extend our synchronization protocol to not only set the source's head as the remote tracking head on the target node but to also update all other remote tracking head's using the source's information.
For each remote tracking head $ A $ of the source node, we compute the lowest common ancestor $ C $ of the corresponding tracking head $ B $ on the target node.
If $ C $ is equal to $ A $, we know that our information on the node's head is more up to date.
If $ C $ is equal to $ B $, the source node had more current information and we update the target's remote tracking head to $ A $.

\subsection{Multi Master - Client}
In a multi master-client setup we have a set of servers who synchronize with each other and a set of clients who can synchronize with any server.
The servers synchronize in a peer-to-peer topology with each other, while the clients can communicate with each other.\\
The advantage of this setup over a pure client-server setting is that we can distribute the synchronization load across multiple servers.
Each server is only responsible for a subset of clients.
The data is kept-up-to date across all servers by synchronizing them with each other in regular intervals.\\
The server's can only make use of the peer-to-peer optimizations described in the previous section.
The client's can make full use of the client-server optimizations we described in section \ref{sec:histo.topologies.master-client}.

\subsection{Hierarchical}
office server + cloud server)
